\newcommand{\bO}{\DC{O}}
\newcommand{\bI}{\DC{I}}
\newcommand{\bitPair}{\DC{bitpair}}
\newcommand{\BitPair}{\TC{BitPair}}
\newcommand{\none}{\DC{none}}
\newcommand{\bit}{\DC{bit}}
\newcommand{\Bit}{\TC{Bit}}
\newcommand{\Number}{\TC{Number}}
\newcommand{\NumCarry}{\TC{NumCarry}}
\newcommand{\numCarry}{\DC{numCarry}}

\section{Interactive Development}

\label{interactive}

In writing dependently typed programs, we often find that expressing
invariant properties in types means that a certain amount of theorem
proving is necessary in order for a definition to typecheck. The
following simple definition, for example, does not typecheck:

\DM{\AR{
\FN{append}\:\Hab\:\AR{\Vect\:\VV{A}\:\VV{n}\to\Vect\:\VV{A}\:\VV{m}\to\Vect\:\VV{A}\:(\VV{m}+\VV{n})}\\ 
\PA{\A\A}{ & \FN{append} & \Vnil & \VV{ys} & \Ret{\VV{ys}}\\ 
 & \FN{append} & (\Vcons\:\VV{x}\:\VV{xs}) & \VV{ys} & \Ret{\Vcons\:\VV{x}\:(\FN{append}\:\VV{xs}\:\VV{ys})}\\ 
}}}

\noindent
The problem is in the second case; the left hand side and right hand
side have different types:

\DM{
\AR{
\FN{append}\:(\Vcons\:\VV{x}\:\VV{xs})\:\vys\Hab\Vect\:\vA\:(\vm+(\suc\:\vn))\\
\Vcons\:\vx\:(\FN{append}\:\VV{xs}\:\vys)\Hab\Vect\:\vA\:(\suc\:(\vm+\vn))
}}

Although these types are different, clearly they are equivalent. We
often find that explicit coercions are needed, which prove
equivalances between indices, to show that a definition is valid. Such
coercions, however, are inconvenient for two reasons:

\begin{enumerate}
\item The required type for the coercion can be hard to find, without
  some assistance from the typechecker, and to write down such types
  can be tedious.
\item Inserting the coercion can make the code less readable.
\end{enumerate}

\subsection{Proposed definitions}

In fact in this case, we can solve the problem simply by changing the type of
$\FN{append}$ so that it returns $\Vect\:\vA\:(\vn+\vm)$, but it will
not always be so simple.
Instead, we offer an alternative means of definign functions using the
$\TryOp$ operator. Using this operator we can give a proposed
definition for a clause, and a name for the coercion we will define
later which proves the equivalence between types:

\DM{\AR{
\FN{append}\:\Hab\:\AR{\Vect\:\VV{A}\:\VV{n}\to\Vect\:\VV{A}\:\VV{m}\to\Vect\:\VV{A}\:(\VV{m}+\VV{n})}\\ 
\PA{\A\A}{ & \FN{append} & \Vnil & \VV{ys} & \Ret{\VV{ys}}\\ 
 & \FN{append} & (\Vcons\:\VV{x}\:\VV{xs}) & \VV{ys} &
  \TryRet{\Vcons\:\VV{x}\:(\FN{append}\:\VV{xs}\:\VV{ys})}{app\_cons}\\ 
}}}

This generates a lemma $\FN{app\_cons}$. Before we can run
$\FN{append}$, we will need to give a definition for $\FN{app\_cons}$.
The typechecker has generated the appropriate type for the lemma,
and we can use the underlying theorem proving capabilities of \Ivor{}
to complete the definition:

\DM{
\FN{app\_cons}\Hab
\AR{
\vA\to(\Vect\:\vA\:\vn)\to(\Vect\:\vA\:\vm)\to\:\to\\
              \fbind{\VV{value}}{\Vect\:\vA\:(\suc\:(\vm+\vn))}
	      {\Vect\:\vA\:(\vn+(\suc\:\vm))}}
}

\noindent
The $\VV{value}$ argument is the proposed return value; we can now see
its type, as generated by the typechecker. The return type is the
type of the left hand side. The r\^{o}le of this lemma is to rewrite
the type. All of the variables on the left hand side are passed as
additional arguments to give the lemma access to the whole context.
The real definition of $\FN{append}$ (internally, not required to be
seen by the programmer) is then:

\DM{\AR{
\FN{append}\:\Hab\:\AR{\Vect\:\VV{A}\:\VV{n}\to\Vect\:\VV{A}\:\VV{m}\to\Vect\:\VV{A}\:(\VV{m}+\VV{n})}\\ 
\PA{\A\A}{ & \FN{append} & \Vnil & \VV{ys} & \Ret{\VV{ys}}\\ 
 & \FN{append} & (\Vcons\:\VV{x}\:\VV{xs}) & \VV{ys} &
  \Ret{\FN{app\_cons}\:\vx\:\vxs\:\vys\:(\Vcons\:\VV{x}\:(\FN{append}\:\VV{xs}\:\VV{ys}))}\\ 
}}}

For the purposes of testing, we provide a function which simply coerces
one index to another, without checking. Obviously, any program which
makes use of this cannot be trusted! However, it allows us to try
proposed definitions and gain some intuition about how we may prove
the required lemmas.

\DM{\FN{suspend\_disbelief}\:\Hab\:\AR{(\VV{m} \Hab \VV{A})\to(\VV{n} \Hab \VV{A})\to\VV{m}=\VV{n}}}

\subsection{Case study --- binary arithmetic}

\label{sec:binary}

Many dependently typed programs make use of natural numbers as indices
to verify that size invariants are maintained. We gave a more complex example
of this technique in~\cite{tfp-ccc}, where we showed a binary adder to
be correct by indexing binary numbers over their natural number
equivalents. However, the requirement to use intermediate lemmas to
show that the natural number invariants were indeed equivalent did
cause the final program to be less readable than desired.

To recap briefly, we define bits as follows, indexed over their
natural number representation:

\DM{\AR{
\Data\hg\:\Bit\:\Hab\:\AR{\Nat\to\Type\hg\Where}\:
\bO\:\Hab\:\AR{\Bit\:\Z}\:\mid \bI\:\Hab\:\AR{\Bit\:(\suc\:\Z)}
}}

We can then build on this to defined pairs of bits, then
numbers and numbers with a carry flag, each of which carry the size of
the corresponding $\Nat$ in their type.

\DM{\AR{
\Data\hg\:\BitPair\:\Hab\:\AR{\Nat\to\Type\hg\Where}\\ 
\begin{array}{rl}
 & \bitPair\:\Hab\:\AR{\Bit\:\VV{c}\to\Bit\:\VV{v}\to\BitPair\:(\VV{v}+(\suc\:(\suc\:\Z))\times\VV{c})}
\end{array}
\medskip
\\
\Data\hg\:\Number\:\Hab\:\AR{\Nat\to\Nat\to\Type\hg\Where}\\ 
\begin{array}{rl}
 & \none\:\Hab\:\AR{\Number\:\Z\:\Z}\\ 
 \mid & \bit\:\Hab\:\AR{\Bit\:\VV{b}\to\Number\:\VV{n}\:\VV{val}\to\\
\Number\:(\suc\:\VV{n})\:(((\suc\:(\suc\:\Z))^{\VV{n}}\times\VV{b})+\VV{val})}
\end{array}
\medskip
\\
\Data\hg\:\NumCarry\:\Hab\:\AR{\Nat\to\Nat\to\Type\hg\Where}\\ 
\begin{array}{rl}
 & \numCarry\:\Hab\:\AR{\Bit\:\VV{c}\to\Number\:\VV{n}\:\VV{val}\to\\
\NumCarry\:\VV{n}\:(((\suc\:(\suc\:\Z))^{\vn}\times\vc)+\VV{val})}
\end{array}

}}

Assuming we have a means of adding bits, a full carry ripple adder can
be implemented as follows, with the full types given. We add the most
significant bits, given the result of adding the rest, as follows:

\DM{\AR{
\FN{addNumberAux}\:\Hab\:\AR{\Bit\:\VV{l}\to\Bit\:\VV{r}\to\NumCarry\:\VV{n}\:\VV{val}\to\\
\NumCarry\:(\suc\:\VV{n})\:(((\suc\:(\suc\:\Z))^\vn)\times(\vl+\vr)+\VV{val})}\\
\PA{\A\A\A}{ & \FN{addNumberAux} & \VV{x} & \VV{y} &
  (\numCarry\:\VV{c}\:\VV{num}) &
  \Ret{\FN{msPair}\:(\FN{addBit}\:\VV{x}\:\VV{y}\:\VV{c})\:\VV{num}}
\\ 
}}}

\noindent
Then the adder is defined recursively:

\DM{\AR{
\FN{addNumber}\:\Hab\:\AR{\Number\:\VV{n}\:\VV{l}\to\Number\:\VV{n}\:\VV{r}\to\Bit\:\VV{carry}\to\\
\NumCarry\:\VV{n}\:(\VV{carry}+\vl+\vr)}
\\
\PA{\A\A\A}{ & 
\FN{addNumber} & \none & \none & \VV{c} & \\
& & \MRet{4}{\numCarry\:\VV{c}\:\none}\\ 
 & \FN{addNumber} & (\bit\:\VV{b1}\:\VV{num1}) &
(\bit\:\VV{b2}\:\VV{num2}) & \VV{c} & \\
& & \MRet{4}{\FN{addNumberAux}\:\VV{b1}\:\VV{b2}\:(\FN{addNumber}\:\VV{num1}\:\VV{num2}\:\VV{c})}\\ 
}}}

Unforunately, and unsurprisingly, neither of these definitions
typecheck, however convinced we might be that this is a correct
implementation. In~\cite{tfp-ccc} we explain the reasons in detail,
and show how to construct the required intermediate lemmas. Now in
\Idris{}, we can achieve this automatically, using the proposed
definition syntax.

\DM{\AR{
\FN{addNumberAux}\:\Hab\:\AR{\Bit\:\VV{l}\to\Bit\:\VV{r}\to\NumCarry\:\VV{n}\:\VV{val}\to\\
\NumCarry\:(\suc\:\VV{n})\:(((\suc\:(\suc\:\Z))^\vn)\times(\vl+\vr)+\VV{val})}\\
\PA{\A\A\A}{ & \FN{addNumberAux} & \VV{x} & \VV{y} &
  (\numCarry\:\VV{c}\:\VV{num}) & \\
& & 
  \MTryRet{4}{\FN{msPair}\:(\FN{addBit}\:\VV{x}\:\VV{y}\:\VV{c})\:\VV{num}}{num\_aux}
\\ 
}}}

\DM{\AR{
\FN{addNumber}\:\Hab\:\AR{\Number\:\VV{n}\:\VV{l}\to\Number\:\VV{n}\:\VV{r}\to\Bit\:\VV{carry}\to\\
\NumCarry\:\VV{n}\:(\VV{carry}+\vl+\vr)}
\\
\PA{\A\A\A}{ & 
\FN{addNumber} & \none & \none & \VV{c} & \\
& & \MTryRet{4}{\numCarry\:\VV{c}\:\none}{none\_case}\\ 
 & \FN{addNumber} & (\bit\:\VV{b1}\:\VV{num1}) &
(\bit\:\VV{b2}\:\VV{num2}) & \VV{c} & \\
& \MsTryRet{5}{\FN{addNumberAux}\:\VV{b1}\:\VV{b2}\:(\FN{addNumber}\:\VV{num1}\:\VV{num2}\:\VV{c})}{bit\_case}\\ 
}}}

We lose little readability from our original failed definition, and
additionally are even in a position to test this function, by using
the above $\FN{suspend\_disbelief}$ function to fill in the proofs.

We would prefer, of course, to prove the lemmas completely. The
typechecker has given us the lemmas $\FN{num\_aux}$, $\FN{none\_case}$
and $\FN{bit\_case}$, which can be proved interactively using
\Ivor{}. We give the type of $\FN{num\_aux}$ to illustrate:

\DM{
\AR{
\FN{num\_aux}\Hab
\AR{
\Bit\:\vc
\to
\Bit\:\vl
\to
\Bit\:\vr
\to
\NumCarry\:\vn\:\VV{val}
\to \\
\fbind{\VV{value}}
{\NumCarry\:(\suc\:\vn)\:
(((\suc\:(\suc\:\Z))^\vn)*(\vr+\vy+\vc)+\VV{val})}
{\\
\NumCarry\:(\suc\:\vn) 
((\suc\:(\suc\:\Z))^\vn\times(\vl+\vr)+
(((\suc\:(\suc\:\Z))^\vn)\times\vc+\VV{val}))}}
\\
}
}

This type is fairly large (and so we are pleased to have the
typechecker construct it for us!) but to prove the
equivalence of indices requirees  straightforward algebraic
manipulation. Such proofs could even be built automatically using a
Presburger arithmetic solver. The main advantage of our approach is
that it cleanly separates these proof requirements from the program,
which aids both construction of the complete, verified program and,
perhaps more importantly, readability of the program.

The full implementation of the binary adder (including a simple I/O
interface) is available online, at
\url{http://www.cs.st-andrews.ac.uk/~eb/drafts/binary.idr}.